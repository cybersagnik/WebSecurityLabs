# MFA Lab 2: Brute-Forcing MFA When You Canâ€™t Bypass It
## WebSecurity 101 Â· Authentication Â· MFA Vulnerabilities

This lab demonstrates a real-world MFA failure mode where the second factor is implemented correctly, yet remains exploitable due to missing enforcement controls.
- In MFA Lab 1, MFA could be bypassed entirely due to broken logic.
- In MFA Lab 2, bypass is no longer possible â€” but brute force is.
--------------------
## Learning Objective

This lab teaches a critical lesson in authentication security:
- Correct verification logic is not enough.
- MFA verification is a high-risk boundary and must be protected with enforcement controls such as rate limiting, expiration, and lockouts.
---------------------------
## Threat Model Summary
| Component               | Status               |
| ----------------------- | -------------------- |
| Password authentication | âœ… Rate-limited       |
| OTP generation          | âœ… Random 4-digit OTP |
| OTP validation          | âœ… Correct            |
| OTP bound to session    | âœ… Yes                |
| OTP expiration          | âŒ No                 |
| OTP attempt limit       | âŒ No                 |
| Session expiration      | âŒ No                 |
- The result is a persistent MFA attack surface.
-------------------------------
## Lab Architecture Overview

### Authentication Flow :

1. User logs in with username + password
2. Server generates a 4-digit OTP
3. OTP is emailed to the user
4. OTP is stored server-side and bound to sessionId
5. User must verify OTP to access protected resource

### Security Assumption (Flawed)
``OTP entropy alone is sufficient protection.``
- This assumption is false.
-----------------------------------
## Project Structure

```js
â”œâ”€â”€ db.js                     # MongoDB connection & schemas
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ task2.js              # Login + OTP generation
â”‚   â”œâ”€â”€ verify-otp.js         # OTP verification (vulnerable)
â”‚   â””â”€â”€ protected-resource.js # Protected endpoint
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ sendOtpEmail.js       # OTP email delivery
â”œâ”€â”€ server.js
â””â”€â”€ README.md
```

--------------------------------------------
## Lab Setup

### Installation
```js
git clone https://github.com/cybersagnik/WebSecurityLabs/new/main/Authentication%20Labs/MFA_VULNERABILITY/Task2
cd Task2
npm install
```

### Start mongodb and server
```js
mongod
node index.js`
```

- On shutdown (Ctrl + C), the database is wiped automatically for a clean lab reset.
-------------------------------------------------
## Test Users

- Users are auto-seeded on startup
  
| Username | Password          | Description                    |
| -------- | ----------------- | ------------------------------ |
| john     | john_otp123     | Intended brute-force target    |
| carlos   | carlos_bypassme | Higher-value protected account |

```js
Email addresses can be updated in the database to point to a test inbox and smtp should be configured in /utils/sendOtpEmail.js
```
--------------------------------------------------
## Key Vulnerability : OTP Brute Force

Why bypass no longer works:
- OTP must match
- OTP must belong to the session
- OTP must be verified before access

This is enforced in the verification logic : verify-otp.js

Why brute force still works
- OTP is only 4 digits (10,000 combinations)
- OTP never expires
- OTP verification endpoint has no rate limiting

Session remains valid indefinitely

This allows attackers to:
- Maintain a valid session
- Submit unlimited OTP guesses
- Eventually complete MFA successfully

### Vulnerable Code (Key Excerpt)
**From OTP verification handler : verify-otp.js**
```js
const otpSession = await OTPSession.findOne({
  sessionId,
  verified: false
});

otpSession.attempts += 1;

if (otpSession.otp !== verification_code) {
  return res.status(401).json({ error: 'Invalid OTP' });
}
```
--------------------------
## ðŸ›¡ How This Should Be Fixed (Not Implemented)

For educational contrast, a secure implementation would require:
- OTP attempt limits per session
- Short OTP expiration window
- Progressive delays or lockouts
- Session invalidation on failure threshold

These fixes are intentionally omitted in this lab.

----------------------------------
## ðŸ§ª Pentesting Approach (Attackerâ€™s Perspective)

This section outlines how a penetration tester or attacker would **assess and exploit** the MFA implementation used in this lab.

The objective is not to bypass MFA logic, but to evaluate whether the **verification boundary is enforced strongly enough**.

---

### 1ï¸âƒ£ Identify the MFA Enforcement Boundary

The first step is to determine **where MFA is actually enforced** in the backend.

Key questions a pentester asks:
- Is OTP verification mandatory for accessing protected resources?
- Does the backend verify MFA completion or only session existence?
- Is MFA enforced server-side or only through UI flow?

This establishes whether MFA is:
- bypassable at the logic level, or  
- enforced but potentially weak

---

### 2ï¸âƒ£ Analyze OTP Characteristics

Once MFA enforcement is confirmed, the OTP itself is evaluated:

- OTP length (4 digits in this lab)
- OTP generation randomness
- OTP reuse across attempts
- OTP binding (user / session)

Short OTPs are not inherently insecure â€”  
they become insecure **when enforcement controls are missing**.

---

### 3ï¸âƒ£ Test OTP Expiration Behavior

A pentester checks whether OTPs:
- expire after a short time window
- remain valid indefinitely
- are invalidated after failed attempts

In this lab:
- OTPs do **not expire**
- The attack window remains open indefinitely

This significantly increases brute-force feasibility.

---

### 4ï¸âƒ£ Assess OTP Verification Rate Limiting

The OTP verification endpoint is treated as a **high-risk attack surface**.

Tests include:
- Submitting repeated OTP guesses
- Observing response consistency
- Checking for throttling, delays, or lockouts
- Monitoring whether attempts are counted or restricted

In this lab:
- Unlimited OTP attempts are allowed
- No per-session or per-IP rate limiting exists

This enables automated brute-force attacks.

---

### 5ï¸âƒ£ Evaluate Session Lifetime During MFA

A critical part of MFA testing is session behavior:

- Does the session expire during MFA?
- Is the session invalidated after repeated OTP failures?
- Is the same session reused before and after MFA?

In this lab:
- Sessions do not expire
- Failed OTP attempts do not invalidate the session

This creates a **persistent MFA attack surface**.

---

### 6ï¸âƒ£ Perform OTP Brute Force

After confirming the above conditions, OTP brute force becomes viable:

- Maintain a valid authentication session
- Submit OTP guesses iteratively
- Observe the success condition
- Complete MFA once the correct OTP is found

This is **not an MFA bypass** â€”  
it is a **forced completion of MFA**.

---

### 7ï¸âƒ£ Validate Post-MFA Authorization

After successful OTP verification, the tester confirms:
- Access to protected resources
- Correct identity resolution
- Authorization boundaries

This validates the **impact** of the vulnerability:
- Account takeover
- Unauthorized access
- Privilege escalation (context-dependent)

---

## ðŸ§  Pentesting Takeaway

> MFA systems rarely fail because OTPs are weak.  
> They fail because verification endpoints are under-protected.

From a pentesting perspective, the absence of:
- attempt limits  
- expiration controls  
- session invalidation  

turns a technically correct MFA implementation into a **brute-forceable authentication boundary**.

---

