const bcrypt = require('bcrypt');
const { User, OTPSession , LoginAttempts} = require('../db');
const sendOtpEmail = require('../utils/sendOtpEmail');

// Helper function to generate OTP
function generateOTP() {
  return Math.floor(1000 + Math.random() * 9000).toString();
}


// Helper function to create sessionId from username (base64 encoding)
function createSessionId(username) {
  return Buffer.from(username).toString('base64');
}

// POST /task-1 - Login endpoint
async function handleLogin(req, res) {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password required' });
    }

    // Rate-limit on basis of username
    const recentAttempts = await LoginAttempts.countDocuments({
      username,
      createdAt: { $gte: new Date(Date.now() - 10 * 60 * 1000) } // last 10 min
    });

    if (recentAttempts > 5) {
      return res.status(429).json({ error: 'Too many login attempts' });
    }

    const user = await User.findOne({ username });
    await LoginAttempts.create({ username });

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    if (!user.email) {
      return res.status(400).json({ error: 'No email associated with account' });
    }

    const otp = generateOTP();
    const sessionId = createSessionId(username);

    await OTPSession.create({
      username,
      otp,
      sessionId,
      verified: false,
      attempts: 0,
    });

    //Sending OTP to user
    await sendOtpEmail(user.email, otp);

    //OTP is tied to sessionId cookie so otpsession depends on user's session validity
    //If session expires or user logs out then otp is invalidated
    //But in this case as session doesn't expire otp verification flag stays true once verified.
    res.cookie('sessionId', sessionId, {
      httpOnly: true,
      sameSite: 'lax'
    });

    res.json({
      message: 'OTP generated',
      otp,
      redirect: '/your-otp'
    });

  } catch (err) {
    console.error('Login error:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
}


module.exports = { handleLogin, createSessionId };
